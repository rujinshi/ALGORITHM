# 冒泡排序
## 实现原理
假设数组中有n个数，比较相邻的两项，如果前者大于后者，就把两个数交换位置。那么第一轮过后就可以选出一个最大的数放在最后面；经过n-1(数组的length-1)轮，就完成了所有数的排序。

## 代码实现

### 原始版
```js
var arr = [9,1,5,8,3,7];
function bubbleSort(arr) {
    // 外循环控制趟数
    for (var i=0;i<arr.length-1;i++) {
        // 内循环用于两两比较
        for (var j=0;j<arr.length-1;j+) {
            if (arr[j] > arr[j+1]) {
                // ES6语法 实现交换数组中两个数
                [arr[j],arr[j+1]] = [ar[j+1],arr[j]];
            }
        }
    }
    return arr; //[1, 3, 5, 7, 8, 9]
}
```
通过上述代码即可实现原始的冒泡排序，但是我们想一下，**外面大循环每比较一趟，就能将一个最大数放到最后面**，因此在内层循环是没有必要将整个数组都遍历的。
更准确来说：
* 第0趟 内层比较arr.length-1次
* 第1趟 内层比较arr.length-1 -1次
* 第2趟 内层比较arr.length-1 -2次

以此类推，也就是要 *从内循环减去外循环中已经跑过的轮数* ，这样就可以避免不必要的比较

### 改进版1
```js
var arr = [9,1,5,8,3,7];
function bubbleSort(arr) {
    // 外循环用于控制比较的趟数
    for (var i=0;i<arr.length-1;i++) {
        // 内循环比较时 减去外循环的趟数-----避免不必要的比较
        for (var j=0;j<arr.length-1-i;j++) {
            if (arr[j] > arr[j+1]) {
                [arr[j],arr[j+1]] = [arr[j+1],arr[j]];
            }
        }
    }
    return arr; //[1, 3, 5, 7, 8, 9]
}
```

虽然说我们已经让内层的循环减去外层的循环，以减少不必要的比较，但是还是会有多余的循环出现。

假设现在有一组数[2,1,3,4,5,6,7,8],那么我们只有前面两个数字需要进行交换，别的都是正常的顺序。

对于改进版1来说还是会无情的遍历已排序好的数字，尽管没有进行交换。

由此我们可以假设一个标志位来记录是否进行了交换，如果没有进行交换，就不要后续的循环判断工作了。

### 改进版2
```js
var arr=[2,1,3,4,5,6,7,8];
function bubbleSort(arr) {
    var len = arr.length-1;
    // 定义标志位
    var flag=true;
    // 若flag为flase则直接退出循环
    for (var i=0;i<len&&flag;i++){
        // 初始flag为flase
        flag=false;
        for (var j=0;j<len-i;j++){
            if (arr[j] > arr[j+1]) {
                [arr[j],arr[j+1]] = [arr[j+1],arr[j]];
                // 如果有交换 flag则为true
                flag=true;
            }
        }
    }
    return arr;
    }
```

## 总结

以上就是冒泡排序的几种思路。虽然在最后有一定的优化，但是总的来说，冒泡排序的平均时间复杂度为O(n^2)，其空间复杂度为O(1)。
